/*!
* \file   TFEL/Material/NonLinearIsotropicNonLinearKinematicViscosity.hxx
* \brief  this file implements the NonLinearIsotropicNonLinearKinematicViscosity Behaviour.
*         File generated by tfel version 4.1.0
* \author Baris Telmen
 */

#ifndef LIB_TFELMATERIAL_NONLINEARISOTROPICNONLINEARKINEMATICVISCOSITY_HXX
#define LIB_TFELMATERIAL_NONLINEARISOTROPICNONLINEARKINEMATICVISCOSITY_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/NonLinearIsotropicNonLinearKinematicViscosityBehaviourData.hxx"
#include"TFEL/Material/NonLinearIsotropicNonLinearKinematicViscosityIntegrationData.hxx"

#include"TFEL/Math/Array/ViewsArray.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/TinyNewtonRaphsonSolver.hxx"
#include"MFront/Aster/Aster.hxx"

namespace tfel::material{

struct NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer
{
static NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer&
get();

double theta;
double epsilon;
unsigned short iterMax;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer();

NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer(const NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer&);

NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer&
operator=(const NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis, typename NumericType, bool use_qt>
struct NonLinearIsotropicNonLinearKinematicViscosity;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
 operator <<(std::ostream&,const NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>&);

/*!
* \class NonLinearIsotropicNonLinearKinematicViscosity
* \brief This class implements the NonLinearIsotropicNonLinearKinematicViscosity behaviour.
* \tparam hypothesis: modelling hypothesis.
* \tparam NumericType: numerical type.
* \author Baris Telmen
* Non - linear isotropic non - linear kinematic 
* with viscosity 
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename NumericType>
struct NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>,
public NonLinearIsotropicNonLinearKinematicViscosityBehaviourData<hypothesis, NumericType, false>,
public NonLinearIsotropicNonLinearKinematicViscosityIntegrationData<hypothesis, NumericType, false>,
public tfel::math::TinyNewtonRaphsonSolver<3*ModellingHypothesisToStensorSize<hypothesis>::value+1, NumericType, NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>>{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<NumericType>::cond);
static_assert(tfel::typetraits::IsReal<NumericType>::cond);

friend std::ostream& operator<< <>(std::ostream&,const NonLinearIsotropicNonLinearKinematicViscosity&);

friend struct tfel::math::TinyNonLinearSolverBase<3*ModellingHypothesisToStensorSize<hypothesis>::value+1, NumericType, NonLinearIsotropicNonLinearKinematicViscosity>;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N, NumericType, false>;
using Type = NumericType;
using numeric_type = typename Types::numeric_type;
using real = typename Types::real;
using time = typename Types::time;
using length = typename Types::length;
using frequency = typename Types::frequency;
using speed = typename Types::speed;
using stress = typename Types::stress;
using strain = typename Types::strain;
using strainrate = typename Types::strainrate;
using stressrate = typename Types::stressrate;
using temperature = typename Types::temperature;
using thermalexpansion = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity = typename Types::massdensity;
using energydensity = typename Types::energydensity;
using TVector = typename Types::TVector;
using DisplacementTVector = typename Types::DisplacementTVector;
using ForceTVector = typename Types::ForceTVector;
using HeatFlux = typename Types::HeatFlux;
using TemperatureGradient = typename Types::TemperatureGradient;
using Stensor = typename Types::Stensor;
using StressStensor = typename Types::StressStensor;
using StressRateStensor = typename Types::StressRateStensor;
using StrainStensor = typename Types::StrainStensor;
using StrainRateStensor = typename Types::StrainRateStensor;
using FrequencyStensor = typename Types::FrequencyStensor;
using Tensor = typename Types::Tensor;
using DeformationGradientTensor = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor = typename Types::DeformationGradientRateTensor;
using StressTensor = typename Types::StressTensor;
using StiffnessTensor = typename Types::StiffnessTensor;
using Stensor4 = typename Types::Stensor4;
using TangentOperator = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<NumericType, false>;

public :

typedef NonLinearIsotropicNonLinearKinematicViscosityBehaviourData<hypothesis, NumericType, false> BehaviourData;
typedef NonLinearIsotropicNonLinearKinematicViscosityIntegrationData<hypothesis, NumericType, false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



tfel::math::View<StrainStensor> deel;
#line 18 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
real& dp;
#line 19 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
tfel::math::ViewsFixedSizeVector<StrainStensor, ushort, 2> da;

#line 33 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
stress lambda;
#line 34 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
stress mu;

NumericType theta;
NumericType epsilon;
ushort iterMax;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
NumericType numerical_jacobian_epsilon;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable eel by variable a
 */
tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfeel_dda(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(tjacobian, 0, StensorSize+1 + mfront_idx * (StensorSize));
}

tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfeel_dda(const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(this->jacobian, 0, StensorSize+1 + mfront_idx * (StensorSize));
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable p by variable a
 */
tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, strain,StrainStensor> dfp_dda(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<strain,StrainStensor>(tjacobian, StensorSize, StensorSize+1 + mfront_idx * (StensorSize));
}

tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, strain,StrainStensor> dfp_dda(const ushort mfront_idx){
return tfel::math::map_derivative<strain,StrainStensor>(this->jacobian, StensorSize, StensorSize+1 + mfront_idx * (StensorSize));
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable a by variable eel
 */
tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfa_ddeel(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(tjacobian, StensorSize+1 + mfront_idx * (StensorSize), 0);
}

tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfa_ddeel(const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(this->jacobian, StensorSize+1 + mfront_idx * (StensorSize), 0);
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable a by variable p
 */
tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,strain> dfa_ddp(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,strain>(tjacobian, StensorSize+1 + mfront_idx * (StensorSize), StensorSize);
}

tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,strain> dfa_ddp(const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,strain>(this->jacobian, StensorSize+1 + mfront_idx * (StensorSize), StensorSize);
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable a by variable a
 */
tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfa_dda(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& tjacobian,const ushort mfront_idx, const ushort mfront_idx2){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(tjacobian, StensorSize+1 + mfront_idx * (StensorSize), StensorSize+1 + mfront_idx2 * (StensorSize));
}

tfel::math::derivative_view_from_tiny_matrix<3*StensorSize+1, StrainStensor,StrainStensor> dfa_dda(const ushort mfront_idx, const ushort mfront_idx2){
return tfel::math::map_derivative<StrainStensor,StrainStensor>(this->jacobian, StensorSize+1 + mfront_idx * (StensorSize), StensorSize+1 + mfront_idx2 * (StensorSize));
}

SMType stiffness_matrix_type;
void computeNumericalJacobian(tfel::math::tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<3*StensorSize+1, NumericType> tzeros(this->zeros);
tvector<3*StensorSize+1, NumericType> tfzeros(this->fzeros);
tmatrix<3*StensorSize+1,3*StensorSize+1, NumericType> tjacobian(this->jacobian);
for(ushort mfront_idx = 0; mfront_idx != 3*StensorSize+1; ++mfront_idx){
this->zeros(mfront_idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<3*StensorSize+1, NumericType> tfzeros2(this->fzeros);
this->zeros(mfront_idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2) / (2 * (this->numerical_jacobian_epsilon));
for(ushort mfront_idx2 = 0; mfront_idx2!= 3*StensorSize+1; ++mfront_idx2){
njacobian(mfront_idx2,mfront_idx) = this->fzeros(mfront_idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

[[nodiscard]] bool
computePartialJacobianInvert(const tfel::math::TinyPermutation<3*StensorSize+1>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(ushort mfront_idx=0; mfront_idx !=StensorSize; ++mfront_idx){
tvector<3*StensorSize+1, NumericType> vect_e(NumericType(0));
vect_e(mfront_idx) = NumericType(1);
if(!TinyMatrixSolve<3*StensorSize+1, NumericType, false>::back_substitute(this->jacobian, jacobian_permutation, vect_e)){
return false;
}
for(ushort mfront_idx2=0; mfront_idx2!=StensorSize; ++mfront_idx2){
partial_jacobian_eel(mfront_idx2,mfront_idx)=vect_e(mfront_idx2);
}
}
return true;
}

[[nodiscard]] bool
computePartialJacobianInvert(const tfel::math::TinyPermutation<3*StensorSize+1>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p)
{
using namespace tfel::math;
for(ushort mfront_idx=0; mfront_idx !=StensorSize; ++mfront_idx){
tvector<3*StensorSize+1, NumericType> vect_e(NumericType(0));
vect_e(mfront_idx) = NumericType(1);
if(!TinyMatrixSolve<3*StensorSize+1, NumericType, false>::back_substitute(this->jacobian, jacobian_permutation, vect_e)){
return false;
}
for(ushort mfront_idx2=0; mfront_idx2!=StensorSize; ++mfront_idx2){
partial_jacobian_eel(mfront_idx2,mfront_idx)=vect_e(mfront_idx2);
}
partial_jacobian_p(mfront_idx)=vect_e(StensorSize);
}
return true;
}

[[nodiscard]] bool
computePartialJacobianInvert(const tfel::math::TinyPermutation<3*StensorSize+1>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::tvector<2, tfel::math::derivative_type<StrainStensor, StrainStensor>>& partial_jacobian_a)
{
using namespace tfel::math;
for(ushort mfront_idx=0; mfront_idx !=StensorSize; ++mfront_idx){
tvector<3*StensorSize+1, NumericType> vect_e(NumericType(0));
vect_e(mfront_idx) = NumericType(1);
if(!TinyMatrixSolve<3*StensorSize+1, NumericType, false>::back_substitute(this->jacobian, jacobian_permutation, vect_e)){
return false;
}
for(ushort mfront_idx2=0; mfront_idx2!=StensorSize; ++mfront_idx2){
partial_jacobian_eel(mfront_idx2,mfront_idx)=vect_e(mfront_idx2);
}
partial_jacobian_p(mfront_idx)=vect_e(StensorSize);
for(ushort mfront_idx2=0; mfront_idx2!=2; ++mfront_idx2){
for(ushort mfront_idx3=0; mfront_idx3!= StensorSize; ++mfront_idx3){
partial_jacobian_a(mfront_idx2)(mfront_idx3,mfront_idx) = vect_e(StensorSize+1+ mfront_idx3 + mfront_idx2 * StensorSize);
}
}
}
return true;
}

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 43 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
this->sig = this->lambda*trace((this->eel+(this->theta)*(this->deel)))*Stensor::Id()+2*this->mu*(this->eel+(this->theta)*(this->deel));
} // end of NonLinearIsotropicNonLinearKinematicViscosity::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 43 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
this->sig = this->lambda*trace(this->eel)*Stensor::Id()+2*this->mu*this->eel;
} // end of NonLinearIsotropicNonLinearKinematicViscosity::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->p += this->dp;
this->a += this->da;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief Default constructor (disabled)
NonLinearIsotropicNonLinearKinematicViscosity() =delete ;
//! \brief Copy constructor (disabled)
NonLinearIsotropicNonLinearKinematicViscosity(const NonLinearIsotropicNonLinearKinematicViscosity&) = delete;
//! \brief Assignement operator (disabled)
NonLinearIsotropicNonLinearKinematicViscosity& operator = (const NonLinearIsotropicNonLinearKinematicViscosity&) = delete;

public:

/*!
* \brief Constructor
*/
NonLinearIsotropicNonLinearKinematicViscosity(const NonLinearIsotropicNonLinearKinematicViscosityBehaviourData<hypothesis, NumericType, false>& src1,
const NonLinearIsotropicNonLinearKinematicViscosityIntegrationData<hypothesis, NumericType, false>& src2)
: NonLinearIsotropicNonLinearKinematicViscosityBehaviourData<hypothesis, NumericType, false>(src1),
NonLinearIsotropicNonLinearKinematicViscosityIntegrationData<hypothesis, NumericType, false>(src2),
deel(tfel::math::map<StrainStensor, 0>(this->zeros)),
dp(this->zeros(StensorSize)),
da(tfel::math::map<2, StrainStensor, StensorSize+1>(this->zeros)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().theta;
this->epsilon = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().epsilon;
this->iterMax = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().iterMax;
this->minimal_time_step_scaling_factor = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().numerical_jacobian_epsilon;
}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERdt_: time increment
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERdT_: temperature increment
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external state variables
 * \param[in] ASTERdext_vars: external state variables increments
 */
NonLinearIsotropicNonLinearKinematicViscosity(const NumericType* const ASTERdt_,
const NumericType* const ASTERT_,
const NumericType* const ASTERdT_,
const NumericType* const ASTERmat,
const NumericType* const ASTERint_vars,
const NumericType* const ASTERext_vars,
const NumericType* const ASTERdext_vars)
: NonLinearIsotropicNonLinearKinematicViscosityBehaviourData<hypothesis, NumericType,false>(ASTERT_,ASTERmat,
ASTERint_vars,ASTERext_vars),
NonLinearIsotropicNonLinearKinematicViscosityIntegrationData<hypothesis, NumericType,false>(ASTERdt_,ASTERdT_,ASTERdext_vars),
deel(tfel::math::map<StrainStensor, 0>(this->zeros)),
dp(this->zeros(StensorSize)),
da(tfel::math::map<2, StrainStensor, StensorSize+1>(this->zeros)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().theta;
this->epsilon = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().epsilon;
this->iterMax = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().iterMax;
this->minimal_time_step_scaling_factor = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = NonLinearIsotropicNonLinearKinematicViscosityParametersInitializer::get().numerical_jacobian_epsilon;
}

/*!
 * \ brief initialize the behaviour with user code
 */
[[nodiscard]] bool initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 38 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
this->lambda = computeLambda(this->young,this->nu);
#line 39 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
this->mu     = computeMu(this->young,this->nu);
return true;
}

/*!
 * \brief set the policy for "out of bounds" conditions
 */
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
  this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

//! \brief check physical bounds and standard bounds
void checkBounds() const{
} // end of checkBounds

[[nodiscard]] IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("NonLinearIsotropicNonLinearKinematicViscosity::computePredictionOperator: "
"unsupported prediction operator flag");
}

real getMinimalTimeStepScalingFactor() const noexcept override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool, real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
[[nodiscard]] IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
this->stiffness_matrix_type = smt;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
tfel::math::TinyNewtonRaphsonSolver<3*ModellingHypothesisToStensorSize<hypothesis>::value+1, NumericType, NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>>::epsilon = this->epsilon;
tfel::math::TinyNewtonRaphsonSolver<3*ModellingHypothesisToStensorSize<hypothesis>::value+1, NumericType, NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>>::iterMax = this->iterMax;
if(!this->solveNonLinearSystem()){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
if (this->stiffness_matrix_type != NOSTIFFNESSREQUESTED){
this->updateOrCheckJacobian();
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
} // end of NonLinearIsotropicNonLinearKinematicViscosity::integrate

bool computeResidual(){
this->computeThermodynamicForces();
return this->computeFdF(false);
}
//! \return the norm of the residual
NumericType computeResidualNorm() {
return tfel::math::norm(this->fzeros) / (3*StensorSize+1);
}
/*!
 * \brief check the convergence of the method
 * \param[in] error: current error
 */
bool checkConvergence(const NumericType error) {
auto converged = error < this->epsilon;
return converged;
}
/*!
 * \brief update the jacobian matrix if required.
 * \param[in] converged: boolean stating if the method is
 * called after the convergence of the algorithm or before
 * the computation of the next correction.
 *
 * This method can be used to compute the jacobian or part
 * of the jacobian numerically. If the jacobian was computed
 * in `computeResidual`, this method can be used to compare it
 * to a numerical approximation.
 */
void updateOrCheckJacobian(){
}
/*!
 * \brief method meant to set bounds on some components
 * of the current Newton correction or to implement a line
 * search.
 */
void processNewCorrection()
{
}
/*!
 * \brief method meant to process the new estimate.
 *
 * This method may be called to apply bounds on the
 * new estimate and update material properties
 * dependending on the current state.
 */
void processNewEstimate(){
this->updateMaterialPropertiesDependantOnStateVariables();
}
/*!
 * \brief solve linear system
 * \return true on success
 * \param[in] m: matrix
 * \param[in,out] v: right hand side on input, solution on output
 */
bool solveLinearSystem(tfel::math::tmatrix<3*StensorSize+1, 3*StensorSize+1, NumericType>& mfront_matrix,tfel::math::tvector<3*StensorSize+1, NumericType>& mfront_vector)const noexcept{
auto mfront_success = true;
mfront_success = tfel::math::TinyNewtonRaphsonSolver<3*ModellingHypothesisToStensorSize<hypothesis>::value+1, NumericType, NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>>::solveLinearSystem(mfront_matrix, mfront_vector);
return mfront_success;
}
/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0;
constexpr auto p_offset = StensorSize;
constexpr auto a_offset = StensorSize+1;
auto feel = tfel::math::map<StrainStensor, 0>(this->fzeros);
real& fp(this->fzeros(StensorSize));
auto fa = tfel::math::map<2, StrainStensor, StensorSize+1>(this->fzeros);
// derivative of residual feel with respect to variable eel
auto&& dfeel_ddeel = tfel::math::map_derivative<0, 0, StrainStensor, StrainStensor>(this->jacobian);
// derivative of residual feel with respect to variable p
auto&& dfeel_ddp = tfel::math::map_derivative<0, StensorSize, StrainStensor, strain>(this->jacobian);
// derivative of residual fp with respect to variable eel
auto&& dfp_ddeel = tfel::math::map_derivative<StensorSize, 0, strain, StrainStensor>(this->jacobian);
// derivative of residual fp with respect to variable p
auto&& dfp_ddp = tfel::math::map_derivative<StensorSize, StensorSize, strain, strain>(this->jacobian);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(), NumericType(0));
for(ushort mfront_idx = 0; mfront_idx != 3*StensorSize+1; ++mfront_idx){
this->jacobian(mfront_idx, mfront_idx) = NumericType(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
#line 48 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
Stensor n(real(0));
#line 49 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const real eps           = 1.e-12;
#line 51 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const strain p_           = (this->p) +theta*(this->dp) ;
#line 52 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
StressStensor scin         = (this->sig) ;
#line 53 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
StrainStensor a_[2];
#line 54 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
for(unsigned short i=0;i!=2;++i){
#line 55 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
a_[i]                   = (this->a)[i]+theta*(this->da)[i];
#line 56 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const StressStensor X_  = (this->C)[i]*a_[i]/1.5;
#line 57 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
scin                    -= X_;
#line 58 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
#line 59 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const stress seq = sigmaeq(scin);
#line 60 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const stress Rp = (this->Rinf) + ((this->R0)-(this->Rinf))*exp(-(this->b)*p_) ;
#line 61 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const real F = seq - Rp ;
#line 62 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
real vp=0.;
#line 63 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
real inv_seq = 0. ;
#line 65 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
if(F > 0){
#line 66 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const real Fexp   = (this->UNsurK)*pow(F*(this->UNsurK),(this->m)-1) ;
#line 67 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
if(seq>eps*(this->young)){
#line 68 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
inv_seq=1./seq ;
#line 69 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
n = 1.5*deviator(scin)*inv_seq;
#line 70 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
vp  = Fexp*F ;
#line 71 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
#line 72 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
feel = (this->deel) -(this->deto) + (this->dp)*n;
#line 73 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
fp   = (this->dp) - vp*(this->dt);
#line 74 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
for(unsigned short i=0;i!=2;++i){
#line 75 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
fa[i] = (this->da)[i] - (this->dp)*(n-(this->g)[i]*a_[i]);
#line 76 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
#line 78 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
const Stensor4 Jmn  = Stensor4::M() - (n^n);
#line 79 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfeel_ddeel += 2.*(this->mu)*theta*(this->dp)*Jmn*inv_seq ;
#line 80 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfeel_ddp    = n;
#line 81 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfp_ddeel    = - Fexp*(this->m)*(this->dt)* 2.*(this->mu)*theta*(n| Stensor4::M() )/1.5;
#line 82 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfp_ddp      = 1 + theta* Fexp *(this->m) *(this->dt)*(this->b)*((this->Rinf)-Rp);
#line 83 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
for(unsigned short i=0;i!=2;++i){
#line 84 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfeel_dda(i)   = -(this->C)[i]*(this->dp)*theta* inv_seq/1.5*Jmn ;
#line 85 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfp_dda(i)     =  Fexp*(this->m)*(this->dt)*(this->C)[i]*theta/1.5*n;
#line 86 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfa_ddeel(i)   = -2.*(this->mu)*theta*(this->dp)*Jmn *inv_seq;
#line 87 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfa_ddp(i)     = -n + (this->g)[i]*a_[i];
#line 88 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfa_dda(i,i)   =  (1+(this->dp)*(this->g)[i]*theta)*Stensor4::Id()+(this->C)[i]*(this->dp)*theta*inv_seq/1.5*Jmn;
#line 89 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
#line 90 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfa_dda(0,1)   =  (this->C)[1]*(this->dp)*theta*inv_seq/1.5*Jmn;
#line 91 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
dfa_dda(1,0)   =  (this->C)[0]*(this->dp)*theta*inv_seq/1.5*Jmn;
#line 92 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
} else {
#line 93 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
feel = (this->deel) - (this->deto);
#line 94 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddp); /* suppress potential warnings */
static_cast<void>(dfp_ddeel); /* suppress potential warnings */
static_cast<void>(dfp_ddp); /* suppress potential warnings */
static_cast<void>(eel_offset);
static_cast<void>(p_offset);
static_cast<void>(a_offset);
return true;
}

std::pair<bool, real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(stress& Psi_s) const
{
Psi_s=stress{0};
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(stress& Psi_d) const
{
Psi_d=stress{0};
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
auto mfront_success = true;
TinyPermutation<3*StensorSize+1> jacobian_permutation;
if(!TinyMatrixSolve<3*StensorSize+1, NumericType, false>::decomp(this->jacobian,jacobian_permutation)){
return false;
}
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(NonLinearIsotropicNonLinearKinematicViscosity& mfront_behaviour_argument,
const tfel::math::TinyPermutation<3*StensorSize+1>& mfront_permutation_argument,
bool& mfront_success_argument)
: mfront_get_partial_jacobian_invert_behaviour(mfront_behaviour_argument),
mfront_get_partial_jacobian_invert_permutation(mfront_permutation_argument),
mfront_success_reference(mfront_success_argument){}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
if(!this->mfront_get_partial_jacobian_invert_behaviour.computePartialJacobianInvert(this->mfront_get_partial_jacobian_invert_permutation, partial_jacobian_eel)){
this->mfront_success_reference = false;
}
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p){
if(!this->mfront_get_partial_jacobian_invert_behaviour.computePartialJacobianInvert(this->mfront_get_partial_jacobian_invert_permutation, partial_jacobian_eel,
partial_jacobian_p)){
this->mfront_success_reference = false;
}
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::tvector<2, tfel::math::derivative_type<StrainStensor, StrainStensor>>& partial_jacobian_a){
if(!this->mfront_get_partial_jacobian_invert_behaviour.computePartialJacobianInvert(this->mfront_get_partial_jacobian_invert_permutation, partial_jacobian_eel,
partial_jacobian_p,
partial_jacobian_a)){
this->mfront_success_reference = false;
}
}
private:
NonLinearIsotropicNonLinearKinematicViscosity& mfront_get_partial_jacobian_invert_behaviour;
const tfel::math::TinyPermutation<3*StensorSize+1>& mfront_get_partial_jacobian_invert_permutation;
bool& mfront_success_reference;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation, mfront_success);
#line 98 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
#line 99 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
computeElasticStiffness<N,Type>::exe((this->Dt),(this->lambda),(this->mu));
#line 100 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
} else if (smt==CONSISTENTTANGENTOPERATOR){
#line 101 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
StiffnessTensor De;
#line 102 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
Stensor4 Je;
#line 103 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
computeElasticStiffness<N,Type>::exe(De,(this->lambda),(this->mu));
#line 104 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
getPartialJacobianInvert(Je);
#line 105 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
(this->Dt) = De*Je;
#line 106 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
} else {
#line 107 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
return false;
#line 108 "NonLinearIsotropicNonLinearKinematicViscosity.mfront"
}
return mfront_success;
}

/*!
* \brief compute the sound velocity
* \param[in] rho_m0: mass density in the reference configuration
*/
speed computeSpeedOfSound(const massdensity&) const {
return speed(0);

}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~NonLinearIsotropicNonLinearKinematicViscosity()
 override = default;

private:

std::pair<bool, real> computeAPrioriTimeStepScalingFactorII() const{
return {true, this->maximal_time_step_scaling_factor};
}

std::pair<bool, real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = tfel::material::None;

}; // end of NonLinearIsotropicNonLinearKinematicViscosity class

template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
operator <<(std::ostream& os,const NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "Rinf : " << b.Rinf << '\n';
os << "R0 : " << b.R0 << '\n';
os << "b : " << b.b << '\n';
os << "C : " << b.C << '\n';
os << "g : " << b.g << '\n';
os << "m : " << b.m << '\n';
os << "UNsurK : " << b.UNsurK << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "p : " << b.p << '\n';
os << "Δp : " << b.dp << '\n';
os << "a : " << b.a << '\n';
os << "Δa : " << b.da << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "θ : " << b.theta << '\n';
os << "ε : " << b.epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
return os;
}

/*!
* Partial specialisation for NonLinearIsotropicNonLinearKinematicViscosity.
*/
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
class MechanicalBehaviourTraits<NonLinearIsotropicNonLinearKinematicViscosity<hypothesis, NumericType, false> >
{
using size_type = unsigned short;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
static constexpr size_type material_properties_nb = 11;
static constexpr size_type internal_variables_nb  = 3*StensorSize+1;
static constexpr size_type external_variables_nb  = 1;
static constexpr size_type external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "NonLinearIsotropicNonLinearKinematicViscosity";
}

};

/*!
* Partial specialisation for NonLinearIsotropicNonLinearKinematicViscosity.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<NonLinearIsotropicNonLinearKinematicViscosity<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS, NumericType, false> >
{
using size_type = unsigned short;
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr size_type material_properties_nb = 0;
static constexpr size_type internal_variables_nb  = 0;
static constexpr size_type external_variables_nb  = 0;
static constexpr size_type external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "NonLinearIsotropicNonLinearKinematicViscosity";
}

};

/*!
* Partial specialisation for NonLinearIsotropicNonLinearKinematicViscosity.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<NonLinearIsotropicNonLinearKinematicViscosity<ModellingHypothesis::PLANESTRESS, NumericType, false> >
{
using size_type = unsigned short;
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr size_type material_properties_nb = 0;
static constexpr size_type internal_variables_nb  = 0;
static constexpr size_type external_variables_nb  = 0;
static constexpr size_type external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "NonLinearIsotropicNonLinearKinematicViscosity";
}

};

} // end of namespace tfel::material

#endif /* LIB_TFELMATERIAL_NONLINEARISOTROPICNONLINEARKINEMATICVISCOSITY_HXX */
