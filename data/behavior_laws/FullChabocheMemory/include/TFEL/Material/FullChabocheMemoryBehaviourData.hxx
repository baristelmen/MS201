/*!
* \file   TFEL/Material/FullChabocheMemoryBehaviourData.hxx
* \brief  this file implements the FullChabocheMemoryBehaviourData class.
*         File generated by tfel version 4.1.0
* \author Baris Telmen
 */

#ifndef LIB_TFELMATERIAL_FULLCHABOCHEMEMORY_BEHAVIOUR_DATA_HXX
#define LIB_TFELMATERIAL_FULLCHABOCHEMEMORY_BEHAVIOUR_DATA_HXX

#include<limits>
#include<string>
#include<sstream>
#include<iostream>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/Abs.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Math/Array/ViewsArrayIO.hxx"
#include"TFEL/Math/Array/fsarrayIO.hxx"
#include"TFEL/Math/Array/runtime_arrayIO.hxx"
#include"TFEL/Math/fsarray.hxx"
#include"TFEL/Math/runtime_array.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/stensor.hxx"
#include"TFEL/Math/Stensor/StensorConceptIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Material/ModellingHypothesis.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel::material{

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename,bool>
class FullChabocheMemoryBehaviourData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType,bool use_qt>
class FullChabocheMemoryIntegrationData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename NumericType>
std::ostream&
 operator <<(std::ostream&,const FullChabocheMemoryBehaviourData<hypothesis, NumericType,false>&);

template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
class FullChabocheMemoryBehaviourData<hypothesis, NumericType,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<NumericType>::cond);
static_assert(tfel::typetraits::IsReal<NumericType>::cond);

friend std::ostream& operator<< <>(std::ostream&,const FullChabocheMemoryBehaviourData&);

/* integration data is declared friend to access   driving variables at the beginning of the time step */
friend class FullChabocheMemoryIntegrationData<hypothesis, NumericType, false>;

static constexpr unsigned short TVectorSize = N;
using StensorDimeToSize = tfel::math::StensorDimeToSize<N>;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
using TensorDimeToSize = tfel::math::TensorDimeToSize<N>;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N, NumericType, false>;
using Type = NumericType;
using numeric_type = typename Types::numeric_type;
using real = typename Types::real;
using time = typename Types::time;
using length = typename Types::length;
using frequency = typename Types::frequency;
using speed = typename Types::speed;
using stress = typename Types::stress;
using strain = typename Types::strain;
using strainrate = typename Types::strainrate;
using stressrate = typename Types::stressrate;
using temperature = typename Types::temperature;
using thermalexpansion = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity = typename Types::massdensity;
using energydensity = typename Types::energydensity;
using TVector = typename Types::TVector;
using DisplacementTVector = typename Types::DisplacementTVector;
using ForceTVector = typename Types::ForceTVector;
using HeatFlux = typename Types::HeatFlux;
using TemperatureGradient = typename Types::TemperatureGradient;
using Stensor = typename Types::Stensor;
using StressStensor = typename Types::StressStensor;
using StressRateStensor = typename Types::StressRateStensor;
using StrainStensor = typename Types::StrainStensor;
using StrainRateStensor = typename Types::StrainRateStensor;
using FrequencyStensor = typename Types::FrequencyStensor;
using Tensor = typename Types::Tensor;
using DeformationGradientTensor = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor = typename Types::DeformationGradientRateTensor;
using StressTensor = typename Types::StressTensor;
using StiffnessTensor = typename Types::StiffnessTensor;
using Stensor4 = typename Types::Stensor4;
using TangentOperator = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<NumericType, false>;

protected:

StrainStensor eto;

StressStensor sig;

#line 11 "FullChabocheMemory.mfront"
stress young;
#line 13 "FullChabocheMemory.mfront"
real nu;
#line 16 "FullChabocheMemory.mfront"
stress R_0;
#line 17 "FullChabocheMemory.mfront"
tfel::math::fsarray<2, stress > C;
#line 18 "FullChabocheMemory.mfront"
tfel::math::fsarray<2, real > g;
#line 19 "FullChabocheMemory.mfront"
real ainf;
#line 20 "FullChabocheMemory.mfront"
real b;
#line 21 "FullChabocheMemory.mfront"
real m;
#line 22 "FullChabocheMemory.mfront"
real K;
#line 23 "FullChabocheMemory.mfront"
real Eta;
#line 24 "FullChabocheMemory.mfront"
real Qm;
#line 25 "FullChabocheMemory.mfront"
real Q0;
#line 26 "FullChabocheMemory.mfront"
real Mu;
#line 27 "FullChabocheMemory.mfront"
tfel::math::fsarray<2, real > delta;

StrainStensor eel;
#line 30 "FullChabocheMemory.mfront"
real p;
#line 32 "FullChabocheMemory.mfront"
tfel::math::fsarray<2, StrainStensor > a;
#line 33 "FullChabocheMemory.mfront"
real q;
#line 34 "FullChabocheMemory.mfront"
Stensor Ksi;
#line 36 "FullChabocheMemory.mfront"
real R;
temperature T;

public:

/*!
* \brief Default constructor
*/
FullChabocheMemoryBehaviourData()
{}

/*!
* \brief copy constructor
*/
FullChabocheMemoryBehaviourData(const FullChabocheMemoryBehaviourData& src)
: eto(src.eto),
sig(src.sig),
young(src.young),
nu(src.nu),
R_0(src.R_0),
C(src.C),
g(src.g),
ainf(src.ainf),
b(src.b),
m(src.m),
K(src.K),
Eta(src.Eta),
Qm(src.Qm),
Q0(src.Q0),
Mu(src.Mu),
delta(src.delta),
eel(src.eel),
p(src.p),
a(src.a),
q(src.q),
Ksi(src.Ksi),
R(src.R),
T(src.T)
{}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external std::ate variables
 */
FullChabocheMemoryBehaviourData(const NumericType* const ASTERT_,const NumericType* const ASTERmat,
const NumericType* const ASTERint_vars
,const NumericType* const)
: young(ASTERmat[0-0]),
nu(ASTERmat[1-0]),
R_0(ASTERmat[2-0]),
ainf(ASTERmat[7-0]),
b(ASTERmat[8-0]),
m(ASTERmat[9-0]),
K(ASTERmat[10-0]),
Eta(ASTERmat[11-0]),
Qm(ASTERmat[12-0]),
Q0(ASTERmat[13-0]),
Mu(ASTERmat[14-0]),
eel(&ASTERint_vars[0]),
p(ASTERint_vars[StensorSize]),
q(ASTERint_vars[3*StensorSize+1]),
Ksi(&ASTERint_vars[3*StensorSize+2]),
R(ASTERint_vars[4*StensorSize+2]),
T(*ASTERT_)
{
C[0] = ASTERmat[3];
C[1] = ASTERmat[4];
g[0] = ASTERmat[5];
g[1] = ASTERmat[6];
delta[0] = ASTERmat[15];
delta[1] = ASTERmat[16];
a[0].import(&ASTERint_vars[StensorSize+1]);
a[1].import(&ASTERint_vars[2*StensorSize+1]);
}

void setASTERBehaviourDataGradients(const NumericType* const ASTERstran)
{
this->eto.importVoigt(ASTERstran);
}

void setASTERBehaviourDataThermodynamicForces(const NumericType* const ASTERstress_)
{
this->sig.importTab(ASTERstress_);
}


/*
* \brief Assignement operator
*/
FullChabocheMemoryBehaviourData&
operator=(const FullChabocheMemoryBehaviourData& src){
this->eto = src.eto;
this->sig = src.sig;
this->young = src.young;
this->nu = src.nu;
this->R_0 = src.R_0;
this->C = src.C;
this->g = src.g;
this->ainf = src.ainf;
this->b = src.b;
this->m = src.m;
this->K = src.K;
this->Eta = src.Eta;
this->Qm = src.Qm;
this->Q0 = src.Q0;
this->Mu = src.Mu;
this->delta = src.delta;
this->eel = src.eel;
this->p = src.p;
this->a = src.a;
this->q = src.q;
this->Ksi = src.Ksi;
this->R = src.R;
this->T = src.T;
return *this;
}

void
ASTERexportStateData(NumericType * const ASTERstress_, NumericType * const ASTERstatev) const
{
using namespace tfel::math;
this->sig.exportTab(ASTERstress_);
exportToBaseTypeArray(this->eel,&ASTERstatev[0]);
ASTERstatev[StensorSize] = this->p;
exportToBaseTypeArray(this->a[0],&ASTERstatev[StensorSize+1]);
exportToBaseTypeArray(this->a[1],&ASTERstatev[2*StensorSize+1]);
ASTERstatev[3*StensorSize+1] = this->q;
exportToBaseTypeArray(this->Ksi,&ASTERstatev[3*StensorSize+2]);
ASTERstatev[4*StensorSize+2] = this->R;
} // end of ASTERexportStateData

}; // end of FullChabocheMemoryBehaviourDataclass

template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
operator <<(std::ostream& os,const FullChabocheMemoryBehaviourData<hypothesis, NumericType, false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "σ : " << b.sig << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "R_0 : " << b.R_0 << '\n';
os << "C : " << b.C << '\n';
os << "g : " << b.g << '\n';
os << "ainf : " << b.ainf << '\n';
os << "b : " << b.b << '\n';
os << "m : " << b.m << '\n';
os << "K : " << b.K << '\n';
os << "Eta : " << b.Eta << '\n';
os << "Qm : " << b.Qm << '\n';
os << "Q0 : " << b.Q0 << '\n';
os << "Mu : " << b.Mu << '\n';
os << "delta : " << b.delta << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "p : " << b.p << '\n';
os << "a : " << b.a << '\n';
os << "q : " << b.q << '\n';
os << "Ksi : " << b.Ksi << '\n';
os << "R : " << b.R << '\n';
os << "T : " << b.T << '\n';
return os;
}

} // end of namespace tfel::material

#endif /* LIB_TFELMATERIAL_FULLCHABOCHEMEMORY_BEHAVIOUR_DATA_HXX */
